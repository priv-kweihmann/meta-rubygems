#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# Copyright (c) 2021, Konrad Weihmann

import argparse
import datetime
import fnmatch
import os
import sys

from packagebot.git import Git
from packagebot.github import GitHub

sys.path.insert(0, os.path.dirname(__file__))


def create_argpaser():
    parser = argparse.ArgumentParser(description='Cherry-pick bot')
    parser.add_argument(
        "--repo_path", default=os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
    parser.add_argument("--git_user", default=os.environ.get("GIT_USER"))
    parser.add_argument("--git_mail", default=os.environ.get("GIT_MAIL"))
    parser.add_argument(
        "--github_user", default=os.environ.get("GIT_USERNAME"))
    parser.add_argument("--github_pat", default=os.environ.get("GIT_PASSWORD"))
    parser.add_argument("--github_repo_user",
                        default=os.environ.get("GITHUB_REPO_USER"))
    parser.add_argument("--github_repo", default=os.environ.get("GITHUB_REPO"))
    parser.add_argument("--cpmode", choices=["all", "firstcommon"], default="all")
    parser.add_argument("source_branch")
    parser.add_argument("target_branch")
    parser.add_argument("ignore_file")

    # export askpass reference
    os.environ["GIT_ASKPASS"] = os.path.join(
        os.path.dirname(__file__), "packagebot", "askpass.py")

    return parser.parse_args()


def __sed(source, needle, replacement):
    cnt = ""
    with open(source) as i:
        cnt = i.read()

    with open(source, "w") as o:
        o.write(cnt.replace(needle, replacement))


def change_log(commits):
    return "\n".join("* {}".format(c.summary) for c in commits)


def get_ignore_file(ignore_file):
    with open(ignore_file) as i:
        return [x.strip() for x in i.readlines() if x.strip()]
    return []


def get_matchings_commits(git, source, target, ignore_file, mode):
    _commits = git.get_fresh_source_commits(source, target, mode)

    _ignores = get_ignore_file(ignore_file)
    res = []
    for commit in _commits:
        pick = True
        for f in commit.stats.files.keys():
            if any(fnmatch.fnmatch(f, x) for x in _ignores):
                pick = False
                break
        if pick:
            res.append(commit)
    return res


def main():
    _args = create_argpaser()

    # export some git variables so we don't need to set them
    # globally
    os.environ["GIT_AUTHOR_NAME"] = _args.git_user
    os.environ["GIT_COMMITTER_NAME"] = _args.git_user
    os.environ["GIT_AUTHOR_EMAIL"] = _args.git_mail
    os.environ["GIT_COMMITTER_EMAIL"] = _args.git_mail

    _main_git = Git(_args.repo_path, _args.git_user, _args.git_mail)
    _github = GitHub(_args.github_user, _args.github_pat,
                     _args.github_repo_user, _args.github_repo)

    _commits = get_matchings_commits(
        _main_git, _args.source_branch, _args.target_branch, _args.ignore_file, _args.cpmode)

    if any(_commits):
        _new_branch_name = "cherry_pick_{}".format(
            datetime.datetime.now().strftime("%Y%m%d"))
        _main_git.create_branch(
            _new_branch_name, from_branch=_args.target_branch, checkout=True)

        _cherry_picks = []
        for c in _commits:
            _cherry_picks += _main_git.cherrypick(c)

        print("Found {} pickable changes".format(len(_cherry_picks)))
        if _cherry_picks:
            # Switch back to source branch to make
            # a few script accessible
            _main_git.checkout(_args.source_branch)
            # publish cherry-pick branch
            _main_git.publish(_new_branch_name)
            # create pull request
            _github.create_pullrequest(
                _args.target_branch.replace("origin/", "", 1),
                "Cherry pick from {}".format(_args.source_branch), change_log(_cherry_picks))


if __name__ == '__main__':
    main()
